import { parseArgs } from 'node:util';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { createError } from '../errors.js';
import { quickstartCommand } from './quickstart.js';

const LIBRARIAN_SECTION_START = '<!-- LIBRARIAN_DOCS_START -->';
const LIBRARIAN_SECTION_END = '<!-- LIBRARIAN_DOCS_END -->';

export interface InitCommandOptions {
  workspace: string;
  args: string[];
  rawArgs: string[];
}

type InitActionStatus = 'created' | 'updated' | 'skipped';

interface InitAction {
  path: string;
  status: InitActionStatus;
  reason?: string;
}

interface InitReport {
  mode: 'scaffold';
  actions: InitAction[];
}

interface McpConfigFile {
  mcpServers?: Record<string, unknown>;
  [key: string]: unknown;
}

function hasScaffoldingFlags(rawArgs: string[]): boolean {
  return rawArgs.includes('--construction')
    || rawArgs.includes('--mcp-config')
    || rawArgs.includes('--claude-md');
}

function slugifyConstructionName(name: string): string {
  const slug = name
    .trim()
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');

  if (!slug) {
    throw createError('INVALID_ARGUMENT', 'Construction name must include at least one alphanumeric character.');
  }

  return slug;
}

function toPascalCase(slug: string): string {
  return slug
    .split('-')
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

function toCamelCase(slug: string): string {
  const pascal = toPascalCase(slug);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

function formatRelative(workspace: string, filePath: string): string {
  return path.relative(workspace, filePath).split(path.sep).join('/');
}

async function readFileIfExists(filePath: string): Promise<string | undefined> {
  try {
    return await fs.readFile(filePath, 'utf8');
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return undefined;
    }
    throw error;
  }
}

async function writeFileSafe(options: {
  filePath: string;
  content: string;
  workspace: string;
  force: boolean;
}): Promise<InitAction> {
  const { filePath, content, workspace, force } = options;
  await fs.mkdir(path.dirname(filePath), { recursive: true });

  const existing = await readFileIfExists(filePath);
  if (existing !== undefined && existing === content) {
    return { path: formatRelative(workspace, filePath), status: 'skipped', reason: 'already up to date' };
  }

  if (existing !== undefined && !force) {
    return { path: formatRelative(workspace, filePath), status: 'skipped', reason: 'already exists (use --force to overwrite)' };
  }

  await fs.writeFile(filePath, content, 'utf8');
  return {
    path: formatRelative(workspace, filePath),
    status: existing === undefined ? 'created' : 'updated',
  };
}

function buildConstructionSource(options: {
  pascalName: string;
  camelName: string;
  slug: string;
}): string {
  const { pascalName, camelName, slug } = options;
  const inputSchemaName = `${camelName}InputSchema`;
  const outputSchemaName = `${camelName}OutputSchema`;
  const inputTypeName = `${pascalName}Input`;
  const outputTypeName = `${pascalName}Output`;

  return `${[
    "import { z } from 'zod';",
    "import type { Construction, Context } from 'librainian/constructions';",
    '',
    `export const ${inputSchemaName} = z.object({`,
    "  target: z.string().min(1, 'target is required'),",
    '  intent: z.string().min(1),',
    '  constraints: z.array(z.string()).optional(),',
    '});',
    '',
    `export type ${inputTypeName} = z.infer<typeof ${inputSchemaName}>;`,
    '',
    `export const ${outputSchemaName} = z.object({`,
    '  summary: z.string(),',
    '  actions: z.array(z.string()),',
    '  risks: z.array(z.string()),',
    '});',
    '',
    `export type ${outputTypeName} = z.infer<typeof ${outputSchemaName}>;`,
    '',
    `export const ${camelName}: Construction<${inputTypeName}, ${outputTypeName}> = {`,
    `  id: 'community:${slug}',`,
    `  name: '${pascalName}',`,
    `  description: '${pascalName} generated by librainian init.',`,
    `  async execute(input: ${inputTypeName}, _context?: Context): Promise<${outputTypeName}> {`,
    '    const validatedInput = ${inputSchemaName}.parse(input);',
    '',
    '    return ${outputSchemaName}.parse({',
    '      summary: `Scaffolded construction for ${validatedInput.target}.`',
      + ',\n'
      + '      actions: [\'Replace this stub with project-specific logic.\'],\n'
      + '      risks: validatedInput.constraints ?? [],\n'
      + '    });',
    '  },',
    '};',
    '',
    `export default ${camelName};`,
    '',
  ].join('\n')}`;
}

function buildConstructionTest(options: { pascalName: string; camelName: string; slug: string }): string {
  const { camelName, slug } = options;
  return `${[
    "import { describe, expect, it } from 'vitest';",
    `import { ${camelName} } from './${slug}';`,
    '',
    `describe('${camelName}', () => {`,
    '  it(\'returns a validated scaffold response\', async () => {',
    `    const result = await ${camelName}.execute({`,
    "      target: 'src/index.ts',",
    "      intent: 'safely refactor',",
    '    });',
    '',
    "    expect(result.summary).toContain('Scaffolded construction');",
    '    expect(Array.isArray(result.actions)).toBe(true);',
    '  });',
    '});',
    '',
  ].join('\n')}`;
}

function buildConstructionDoc(options: { pascalName: string; slug: string }): string {
  const { pascalName, slug } = options;
  return `${[
    `# ${pascalName}`,
    '',
    `Generated by \`librainian init --construction ${pascalName}\`.`,
    '',
    '## Files',
    '',
    `- \`.librarian/constructions/${slug}.ts\``,
    `- \`.librarian/constructions/${slug}.test.ts\``,
    `- \`docs/constructions/${slug}.md\``,
    '',
    '## Next Steps',
    '',
    '1. Define a domain-specific input schema.',
    '2. Replace the stubbed execute logic with real retrieval + analysis.',
    '3. Expand tests to cover success and safety cases.',
    '',
  ].join('\n')}`;
}

async function scaffoldConstruction(options: {
  workspace: string;
  constructionName: string;
  force: boolean;
}): Promise<InitAction[]> {
  const { workspace, constructionName, force } = options;
  const slug = slugifyConstructionName(constructionName);
  const pascalName = toPascalCase(slug);
  const camelName = toCamelCase(slug);

  const constructionPath = path.join(workspace, '.librarian', 'constructions', `${slug}.ts`);
  const testPath = path.join(workspace, '.librarian', 'constructions', `${slug}.test.ts`);
  const docsPath = path.join(workspace, 'docs', 'constructions', `${slug}.md`);

  const [constructionAction, testAction, docsAction] = await Promise.all([
    writeFileSafe({
      filePath: constructionPath,
      content: buildConstructionSource({ pascalName, camelName, slug }),
      workspace,
      force,
    }),
    writeFileSafe({
      filePath: testPath,
      content: buildConstructionTest({ pascalName, camelName, slug }),
      workspace,
      force,
    }),
    writeFileSafe({
      filePath: docsPath,
      content: buildConstructionDoc({ pascalName, slug }),
      workspace,
      force,
    }),
  ]);

  return [constructionAction, testAction, docsAction];
}

function buildDesiredMcpEntry(workspace: string): Record<string, unknown> {
  return {
    command: 'npx',
    args: ['-y', 'librainian', 'mcp'],
    env: {
      LIBRARIAN_WORKSPACE: workspace,
    },
  };
}

async function scaffoldMcpConfig(options: {
  workspace: string;
  force: boolean;
}): Promise<InitAction> {
  const { workspace, force } = options;
  const filePath = path.join(workspace, '.mcp.json');
  const desiredEntry = buildDesiredMcpEntry(workspace);

  const existingRaw = await readFileIfExists(filePath);
  let parsed: McpConfigFile = {};

  if (existingRaw !== undefined) {
    try {
      parsed = JSON.parse(existingRaw) as McpConfigFile;
    } catch {
      throw createError('INVALID_ARGUMENT', '.mcp.json exists but is not valid JSON.');
    }
  }

  if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
    throw createError('INVALID_ARGUMENT', '.mcp.json must contain a JSON object.');
  }

  const existingServers = parsed.mcpServers;
  if (existingServers !== undefined && (typeof existingServers !== 'object' || existingServers === null || Array.isArray(existingServers))) {
    throw createError('INVALID_ARGUMENT', '.mcp.json field "mcpServers" must be a JSON object.');
  }

  const mcpServers: Record<string, unknown> = { ...(existingServers as Record<string, unknown> | undefined) };
  const existingLibrarianEntry = mcpServers.librarian;

  if (existingLibrarianEntry !== undefined) {
    const isSame = JSON.stringify(existingLibrarianEntry) === JSON.stringify(desiredEntry);
    if (!isSame && !force) {
      return {
        path: '.mcp.json',
        status: 'skipped',
        reason: 'librarian MCP entry already exists (use --force to overwrite)',
      };
    }
    if (isSame) {
      return {
        path: '.mcp.json',
        status: 'skipped',
        reason: 'already up to date',
      };
    }
  }

  mcpServers.librarian = desiredEntry;
  const updated: McpConfigFile = {
    ...parsed,
    mcpServers,
  };

  const nextRaw = `${JSON.stringify(updated, null, 2)}\n`;
  if (existingRaw === nextRaw) {
    return {
      path: '.mcp.json',
      status: 'skipped',
      reason: 'already up to date',
    };
  }

  await fs.writeFile(filePath, nextRaw, 'utf8');
  return {
    path: '.mcp.json',
    status: existingRaw === undefined ? 'created' : 'updated',
  };
}

function buildClaudeSection(): string {
  return [
    LIBRARIAN_SECTION_START,
    '',
    '## LiBrainian: Agent Operating Notes',
    '',
    '> Generated by `librainian init --claude-md`.',
    '',
    '### Default Workflow',
    '- Start with `librainian status` to confirm index readiness.',
    '- Run `librainian query "<intent>"` before editing unfamiliar code.',
    '- Use `librainian check --diff working-tree` before finalizing patches.',
    '',
    '### MCP Setup',
    'Register LiBrainian MCP in Claude Code:',
    '',
    '```bash',
    'claude mcp add librainian -- npx librainian mcp',
    '```',
    '',
    '### Notes',
    '- `librainian mcp --print-config` prints client snippets.',
    '- `librainian bootstrap --force` refreshes stale indexes.',
    '',
    LIBRARIAN_SECTION_END,
    '',
  ].join('\n');
}

function upsertLibrarianSection(content: string, section: string): string {
  const managedSection = section.trimEnd();
  const start = content.indexOf(LIBRARIAN_SECTION_START);
  const end = content.indexOf(LIBRARIAN_SECTION_END);

  if (start !== -1 && end !== -1 && end > start) {
    const before = content.slice(0, start).trimEnd();
    const after = content.slice(end + LIBRARIAN_SECTION_END.length).trim();
    const parts = [before, managedSection, after].filter((part) => part.length > 0);
    return `${parts.join('\n\n')}\n`;
  }

  if (start !== -1 && end === -1) {
    const before = content.slice(0, start).trimEnd();
    return before.length > 0
      ? `${before}\n\n${managedSection}\n`
      : `${managedSection}\n`;
  }

  const trimmed = content.trimEnd();
  if (trimmed.length === 0) {
    return `${managedSection}\n`;
  }
  return `${trimmed}\n\n---\n\n${managedSection}\n`;
}

async function scaffoldClaudeMd(options: {
  workspace: string;
  force: boolean;
}): Promise<InitAction> {
  const { workspace } = options;
  const filePath = path.join(workspace, 'CLAUDE.md');
  const existing = await readFileIfExists(filePath);
  const baseContent = existing ?? '# CLAUDE.md\n\n';
  const section = buildClaudeSection();
  const nextContent = upsertLibrarianSection(baseContent, section);

  if (existing !== undefined && existing === nextContent) {
    return {
      path: 'CLAUDE.md',
      status: 'skipped',
      reason: 'already up to date',
    };
  }

  await fs.writeFile(filePath, nextContent, 'utf8');
  return {
    path: 'CLAUDE.md',
    status: existing === undefined ? 'created' : 'updated',
  };
}

function printHumanReport(report: InitReport): void {
  for (const action of report.actions) {
    const prefix = action.status === 'skipped' ? 'Skipped' : action.status === 'updated' ? 'Updated' : 'Created';
    const reason = action.reason ? ` (${action.reason})` : '';
    console.log(`${prefix}: ${action.path}${reason}`);
  }

  if (report.actions.some((action) => action.path === '.mcp.json' && action.status !== 'skipped')) {
    console.log('Add to Claude Code with: claude mcp add librainian -- npx librainian mcp');
  }
}

export async function initCommand(options: InitCommandOptions): Promise<void> {
  const { workspace, rawArgs } = options;

  if (!hasScaffoldingFlags(rawArgs)) {
    await quickstartCommand(options);
    return;
  }

  const { values } = parseArgs({
    args: rawArgs.slice(1),
    options: {
      construction: { type: 'string' },
      'mcp-config': { type: 'boolean', default: false },
      'claude-md': { type: 'boolean', default: false },
      force: { type: 'boolean', default: false },
      json: { type: 'boolean', default: false },
    },
    allowPositionals: true,
    strict: false,
  });

  const constructionName = typeof values.construction === 'string' ? values.construction.trim() : undefined;
  const requestedConstruction = rawArgs.includes('--construction');
  const withMcpConfig = values['mcp-config'] as boolean;
  const withClaudeMd = values['claude-md'] as boolean;
  const force = values.force as boolean;
  const json = values.json as boolean;

  if (requestedConstruction && !constructionName) {
    throw createError('INVALID_ARGUMENT', 'Missing required value: --construction <name>');
  }

  if (!constructionName && !withMcpConfig && !withClaudeMd) {
    throw createError('INVALID_ARGUMENT', 'No init targets specified. Use --construction <name>, --mcp-config, and/or --claude-md.');
  }

  const actions: InitAction[] = [];

  if (constructionName) {
    const constructionActions = await scaffoldConstruction({
      workspace,
      constructionName,
      force,
    });
    actions.push(...constructionActions);
  }

  if (withMcpConfig) {
    actions.push(await scaffoldMcpConfig({ workspace, force }));
  }

  if (withClaudeMd) {
    actions.push(await scaffoldClaudeMd({ workspace, force }));
  }

  const report: InitReport = {
    mode: 'scaffold',
    actions,
  };

  if (json) {
    console.log(JSON.stringify(report, null, 2));
    return;
  }

  printHumanReport(report);
}
