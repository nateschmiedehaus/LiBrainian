/**
 * @fileoverview W3C PROV-JSON Export for Evidence Chains (WU-THIMPL-203)
 *
 * Exports evidence chains in W3C PROV-JSON format for interoperability.
 * PROV is a standard for provenance information, allowing evidence chains
 * to be shared, analyzed, and visualized by PROV-compatible tools.
 *
 * @see https://www.w3.org/TR/prov-json/
 * @see https://www.w3.org/TR/prov-dm/
 * @packageDocumentation
 */

import type {
  EvidenceChain,
  EvidenceEntry,
  EvidenceId,
  EvidenceKind,
  EvidenceProvenance,
  ProvenanceSource,
} from './evidence_ledger.js';
import { getTypedRelations, type EvidenceRelationType } from './evidence_ledger.js';

// ============================================================================
// PROV-JSON TYPES
// ============================================================================

/**
 * PROV-JSON Entity: A physical, digital, conceptual, or other kind of thing
 * with some fixed aspects.
 *
 * In our model: Evidence entries are entities.
 */
export interface PROVEntity {
  /** Entity type (optional, for PROV-N compatibility) */
  'prov:type'?: string | string[];
  /** Human-readable label */
  'prov:label'?: string;
  /** Location associated with entity */
  'prov:location'?: string;
  /** Custom attributes */
  [key: `librarian:${string}`]: unknown;
}

/**
 * PROV-JSON Activity: Something that occurs over a period of time and
 * acts upon or with entities.
 *
 * In our model: Evidence extraction/synthesis activities.
 */
export interface PROVActivity {
  /** Start time (ISO 8601) */
  'prov:startTime'?: string;
  /** End time (ISO 8601) */
  'prov:endTime'?: string;
  /** Activity type */
  'prov:type'?: string | string[];
  /** Human-readable label */
  'prov:label'?: string;
  /** Custom attributes */
  [key: `librarian:${string}`]: unknown;
}

/**
 * PROV-JSON Agent: Something that bears some form of responsibility for
 * an activity or entity.
 *
 * In our model: LLMs, parsers, tools, humans.
 */
export interface PROVAgent {
  /** Agent type */
  'prov:type'?: string | string[];
  /** Human-readable label */
  'prov:label'?: string;
  /** Custom attributes */
  [key: `librarian:${string}`]: unknown;
}

/**
 * PROV-JSON Relation with identifier and attributes.
 */
export interface PROVRelation {
  /** The entity being described */
  'prov:entity'?: string;
  /** The activity that generated this */
  'prov:activity'?: string;
  /** The agent responsible */
  'prov:agent'?: string;
  /** The generation entity (for wasDerivedFrom) */
  'prov:usedEntity'?: string;
  /** The generated entity (for wasDerivedFrom) */
  'prov:generatedEntity'?: string;
  /** Time of the relation */
  'prov:time'?: string;
  /** Custom attributes */
  [key: `librarian:${string}`]: unknown;
}

/**
 * Complete PROV-JSON Document.
 *
 * @see https://www.w3.org/TR/prov-json/#prov-json-serialization
 */
export interface PROVDocument {
  /** Namespace prefixes */
  prefix: Record<string, string>;
  /** Entities in the provenance graph */
  entity: Record<string, PROVEntity>;
  /** Activities in the provenance graph */
  activity: Record<string, PROVActivity>;
  /** Agents in the provenance graph */
  agent: Record<string, PROVAgent>;
  /** wasGeneratedBy relations: entity was generated by activity */
  wasGeneratedBy: Record<string, PROVRelation>;
  /** wasDerivedFrom relations: entity was derived from another entity */
  wasDerivedFrom: Record<string, PROVRelation>;
  /** wasAttributedTo relations: entity was attributed to agent */
  wasAttributedTo: Record<string, PROVRelation>;
  /** used relations: activity used entity */
  used?: Record<string, PROVRelation>;
  /** wasAssociatedWith relations: activity was associated with agent */
  wasAssociatedWith?: Record<string, PROVRelation>;
  /** actedOnBehalfOf relations: agent acted on behalf of another agent */
  actedOnBehalfOf?: Record<string, PROVRelation>;
}

// ============================================================================
// EXPORT OPTIONS
// ============================================================================

/**
 * Options for PROV export.
 */
export interface PROVExportOptions {
  /** Base URI for entity identifiers (default: 'urn:librarian:evidence:') */
  baseUri?: string;
  /** Whether to include detailed payloads in entities (default: false for size) */
  includePayloads?: boolean;
  /** Whether to include confidence values (default: true) */
  includeConfidence?: boolean;
  /** Custom namespace prefix (default: 'librarian') */
  namespacePrefix?: string;
}

/**
 * Default export options.
 */
export const DEFAULT_PROV_EXPORT_OPTIONS: Required<PROVExportOptions> = {
  baseUri: 'urn:librarian:evidence:',
  includePayloads: false,
  includeConfidence: true,
  namespacePrefix: 'librarian',
};

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

/**
 * Export an evidence chain to W3C PROV-JSON format.
 *
 * WU-THIMPL-203: W3C PROV-JSON export for evidence chains.
 *
 * ## PROV Mapping
 *
 * Evidence entries map to PROV concepts as follows:
 * - **Entity**: Each EvidenceEntry becomes a PROV Entity
 * - **Activity**: Evidence extraction/synthesis operations become Activities
 * - **Agent**: Provenance source (LLM, parser, tool) becomes an Agent
 * - **wasGeneratedBy**: Links entity to the activity that created it
 * - **wasDerivedFrom**: Links entity to its source entities (relatedEntries)
 * - **wasAttributedTo**: Links entity to the responsible agent
 *
 * ## Example Output
 *
 * ```json
 * {
 *   "prefix": {
 *     "librarian": "urn:librarian:evidence:",
 *     "prov": "http://www.w3.org/ns/prov#"
 *   },
 *   "entity": {
 *     "librarian:ev_123": {
 *       "prov:type": "extraction",
 *       "prov:label": "Function extraction: myFunc",
 *       "librarian:kind": "extraction",
 *       "librarian:confidence": 0.95
 *     }
 *   },
 *   "activity": { ... },
 *   "agent": { ... },
 *   "wasGeneratedBy": { ... },
 *   "wasDerivedFrom": { ... },
 *   "wasAttributedTo": { ... }
 * }
 * ```
 *
 * @param chain - The evidence chain to export
 * @param options - Export options
 * @returns PROV-JSON document
 *
 * @see https://www.w3.org/TR/prov-json/
 */
export function exportToPROV(
  chain: EvidenceChain,
  options?: PROVExportOptions
): PROVDocument {
  const opts = { ...DEFAULT_PROV_EXPORT_OPTIONS, ...options };
  const ns = opts.namespacePrefix;

  const doc: PROVDocument = {
    prefix: {
      [ns]: opts.baseUri,
      prov: 'http://www.w3.org/ns/prov#',
      xsd: 'http://www.w3.org/2001/XMLSchema#',
    },
    entity: {},
    activity: {},
    agent: {},
    wasGeneratedBy: {},
    wasDerivedFrom: {},
    wasAttributedTo: {},
    used: {},
    wasAssociatedWith: {},
  };

  // Track agents to avoid duplicates
  const agentIds = new Set<string>();

  // Process each evidence entry
  for (const entry of chain.evidence) {
    const entityId = `${ns}:${entry.id}`;
    const activityId = `${ns}:activity_${entry.id}`;
    const agentId = getAgentId(entry.provenance, ns);

    // Create Entity
    doc.entity[entityId] = createPROVEntity(entry, opts);

    // Create Activity
    doc.activity[activityId] = createPROVActivity(entry, opts);

    // Create Agent (if not already created)
    if (agentId && !agentIds.has(agentId)) {
      doc.agent[agentId] = createPROVAgent(entry.provenance, opts);
      agentIds.add(agentId);
    }

    // wasGeneratedBy: entity was generated by activity
    doc.wasGeneratedBy[`${ns}:gen_${entry.id}`] = {
      'prov:entity': entityId,
      'prov:activity': activityId,
      'prov:time': entry.timestamp.toISOString(),
    };

    // wasAttributedTo: entity was attributed to agent
    if (agentId) {
      doc.wasAttributedTo[`${ns}:attr_${entry.id}`] = {
        'prov:entity': entityId,
        'prov:agent': agentId,
      };
    }

    // wasAssociatedWith: activity was associated with agent
    if (agentId && doc.wasAssociatedWith) {
      doc.wasAssociatedWith[`${ns}:assoc_${entry.id}`] = {
        'prov:activity': activityId,
        'prov:agent': agentId,
      };
    }

    // wasDerivedFrom: link to related/source entries
    const relations = getTypedRelations(entry);
    for (let i = 0; i < relations.length; i++) {
      const relation = relations[i];
      const sourceEntityId = `${ns}:${relation.id}`;
      const derivationId = `${ns}:deriv_${entry.id}_${i}`;

      doc.wasDerivedFrom[derivationId] = {
        'prov:generatedEntity': entityId,
        'prov:usedEntity': sourceEntityId,
        [`${ns}:relationType`]: relation.type,
      };

      // used: activity used the source entity
      if (doc.used) {
        doc.used[`${ns}:used_${entry.id}_${i}`] = {
          'prov:activity': activityId,
          'prov:entity': sourceEntityId,
        };
      }
    }
  }

  return doc;
}

/**
 * Export an evidence chain to PROV-JSON string.
 *
 * WU-THIMPL-203: Convenience wrapper for JSON serialization.
 *
 * @param chain - The evidence chain to export
 * @param options - Export options
 * @param pretty - Whether to pretty-print the JSON (default: true)
 * @returns JSON string representation of PROV document
 */
export function exportToPROVJSON(
  chain: EvidenceChain,
  options?: PROVExportOptions,
  pretty: boolean = true
): string {
  const doc = exportToPROV(chain, options);
  return JSON.stringify(doc, null, pretty ? 2 : undefined);
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Create a PROV Entity from an evidence entry.
 */
function createPROVEntity(
  entry: EvidenceEntry,
  opts: Required<PROVExportOptions>
): PROVEntity {
  const entity: PROVEntity = {
    'prov:type': mapEvidenceKindToType(entry.kind),
    'prov:label': generateEntityLabel(entry),
    [`${opts.namespacePrefix}:kind`]: entry.kind,
    [`${opts.namespacePrefix}:timestamp`]: entry.timestamp.toISOString(),
  };

  if (opts.includeConfidence && entry.confidence) {
    if (entry.confidence.type === 'deterministic' ||
        entry.confidence.type === 'derived' ||
        entry.confidence.type === 'measured') {
      entity[`${opts.namespacePrefix}:confidence`] = entry.confidence.value;
    } else if (entry.confidence.type === 'bounded') {
      entity[`${opts.namespacePrefix}:confidenceLow`] = entry.confidence.low;
      entity[`${opts.namespacePrefix}:confidenceHigh`] = entry.confidence.high;
    } else {
      entity[`${opts.namespacePrefix}:confidenceAbsent`] = entry.confidence.reason;
    }
  }

  if (opts.includePayloads) {
    entity[`${opts.namespacePrefix}:payload`] = entry.payload;
  }

  if (entry.sessionId) {
    entity[`${opts.namespacePrefix}:sessionId`] = entry.sessionId;
  }

  return entity;
}

/**
 * Create a PROV Activity from an evidence entry.
 */
function createPROVActivity(
  entry: EvidenceEntry,
  opts: Required<PROVExportOptions>
): PROVActivity {
  const activity: PROVActivity = {
    'prov:type': `${opts.namespacePrefix}:${entry.kind}_activity`,
    'prov:label': `${entry.provenance.method} (${entry.provenance.source})`,
    'prov:endTime': entry.timestamp.toISOString(),
    [`${opts.namespacePrefix}:method`]: entry.provenance.method,
    [`${opts.namespacePrefix}:source`]: entry.provenance.source,
  };

  if (entry.provenance.inputHash) {
    activity[`${opts.namespacePrefix}:inputHash`] = entry.provenance.inputHash;
  }

  return activity;
}

/**
 * Create a PROV Agent from provenance information.
 */
function createPROVAgent(
  provenance: EvidenceProvenance,
  opts: Required<PROVExportOptions>
): PROVAgent {
  const agent: PROVAgent = {
    'prov:type': mapSourceToAgentType(provenance.source),
    'prov:label': getAgentLabel(provenance),
    [`${opts.namespacePrefix}:source`]: provenance.source,
  };

  if (provenance.agent) {
    agent[`${opts.namespacePrefix}:agentType`] = provenance.agent.type;
    agent[`${opts.namespacePrefix}:agentIdentifier`] = provenance.agent.identifier;
    if (provenance.agent.version) {
      agent[`${opts.namespacePrefix}:agentVersion`] = provenance.agent.version;
    }
  }

  return agent;
}

/**
 * Generate a unique agent ID from provenance.
 */
function getAgentId(provenance: EvidenceProvenance, ns: string): string {
  if (provenance.agent) {
    const identifier = provenance.agent.identifier.replace(/[^a-zA-Z0-9_-]/g, '_');
    return `${ns}:agent_${provenance.agent.type}_${identifier}`;
  }
  return `${ns}:agent_${provenance.source}`;
}

/**
 * Generate a human-readable label for an agent.
 */
function getAgentLabel(provenance: EvidenceProvenance): string {
  if (provenance.agent) {
    const version = provenance.agent.version ? ` v${provenance.agent.version}` : '';
    return `${provenance.agent.identifier}${version} (${provenance.agent.type})`;
  }
  return provenance.source;
}

/**
 * Map evidence kind to PROV type.
 */
function mapEvidenceKindToType(kind: EvidenceKind): string {
  const typeMap: Record<EvidenceKind, string> = {
    extraction: 'prov:Entity',
    retrieval: 'prov:Entity',
    synthesis: 'prov:Entity',
    claim: 'prov:Entity',
    verification: 'prov:Entity',
    contradiction: 'prov:Entity',
    feedback: 'prov:Entity',
    outcome: 'prov:Entity',
    tool_call: 'prov:Entity',
    episode: 'prov:Entity',
    calibration: 'prov:Entity',
  };
  return typeMap[kind] || 'prov:Entity';
}

/**
 * Map provenance source to PROV agent type.
 */
function mapSourceToAgentType(source: ProvenanceSource): string {
  const typeMap: Record<ProvenanceSource, string> = {
    ast_parser: 'prov:SoftwareAgent',
    llm_synthesis: 'prov:SoftwareAgent',
    embedding_search: 'prov:SoftwareAgent',
    user_input: 'prov:Person',
    tool_output: 'prov:SoftwareAgent',
    system_observation: 'prov:SoftwareAgent',
  };
  return typeMap[source] || 'prov:Agent';
}

/**
 * Generate a human-readable label for an evidence entry.
 */
function generateEntityLabel(entry: EvidenceEntry): string {
  // Cast to unknown first, then to Record for type safety
  const payload = entry.payload as unknown as Record<string, unknown>;

  switch (entry.kind) {
    case 'extraction':
      return `Extraction: ${(payload.entity as { name?: string })?.name || 'unknown'}`;
    case 'retrieval':
      return `Retrieval: "${String(payload.query || '').slice(0, 50)}"`;
    case 'synthesis':
      return `Synthesis: ${payload.synthesisType || 'unknown'}`;
    case 'claim':
      return `Claim: "${String(payload.claim || '').slice(0, 50)}"`;
    case 'verification':
      return `Verification: ${payload.result || 'unknown'}`;
    case 'contradiction':
      return `Contradiction: ${payload.contradictionType || 'unknown'}`;
    case 'feedback':
      return `Feedback: ${payload.feedbackType || 'unknown'}`;
    case 'outcome':
      return `Outcome: ${(payload.actual as { outcome?: string })?.outcome || 'unknown'}`;
    case 'tool_call':
      return `Tool: ${payload.toolName || 'unknown'}`;
    case 'episode':
      return `Episode: "${String(payload.query || '').slice(0, 50)}"`;
    case 'calibration':
      return `Calibration: ${payload.operationType || 'unknown'}`;
    default:
      return `Evidence: ${entry.kind}`;
  }
}

// ============================================================================
// VALIDATION
// ============================================================================

/**
 * Validate that a PROV document is well-formed.
 *
 * Checks:
 * - All referenced entities exist
 * - All referenced activities exist
 * - All referenced agents exist
 * - Required fields are present
 *
 * @param doc - PROV document to validate
 * @returns Validation result with any errors
 */
export function validatePROVDocument(doc: PROVDocument): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  // Check wasGeneratedBy references
  for (const [id, rel] of Object.entries(doc.wasGeneratedBy)) {
    if (rel['prov:entity'] && !doc.entity[rel['prov:entity']]) {
      errors.push(`wasGeneratedBy ${id}: references unknown entity ${rel['prov:entity']}`);
    }
    if (rel['prov:activity'] && !doc.activity[rel['prov:activity']]) {
      errors.push(`wasGeneratedBy ${id}: references unknown activity ${rel['prov:activity']}`);
    }
  }

  // Check wasDerivedFrom references
  for (const [id, rel] of Object.entries(doc.wasDerivedFrom)) {
    if (rel['prov:generatedEntity'] && !doc.entity[rel['prov:generatedEntity']]) {
      errors.push(`wasDerivedFrom ${id}: references unknown generated entity ${rel['prov:generatedEntity']}`);
    }
    if (rel['prov:usedEntity'] && !doc.entity[rel['prov:usedEntity']]) {
      errors.push(`wasDerivedFrom ${id}: references unknown used entity ${rel['prov:usedEntity']}`);
    }
  }

  // Check wasAttributedTo references
  for (const [id, rel] of Object.entries(doc.wasAttributedTo)) {
    if (rel['prov:entity'] && !doc.entity[rel['prov:entity']]) {
      errors.push(`wasAttributedTo ${id}: references unknown entity ${rel['prov:entity']}`);
    }
    if (rel['prov:agent'] && !doc.agent[rel['prov:agent']]) {
      errors.push(`wasAttributedTo ${id}: references unknown agent ${rel['prov:agent']}`);
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
